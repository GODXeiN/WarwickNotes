\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{amsfonts}
\usepackage{titling}
\usepackage{lipsum}
\usepackage[left=1in, right=1in, bottom=1in, top=1in]{geometry}
\usepackage{amsthm}
\usepackage{tcolorbox}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{tikz}
\usepackage{cases}
\usepackage{apacite}
\usepackage{tkz-berge}
\usepackage{url}
\usepackage{tgtermes}
\usepackage{sectsty}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{float}
\usepackage{amsmath, amssymb}


% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{color}
\newcommand{\incfig}[2][1]{%
    \def\svgwidth{#1\columnwidth}
    \import{./figures/}{#2.pdf_tex}
}

%mathstyling
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]
\newtheorem{axiom}{Axiom}
\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}

\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}

\pdfsuppresswarningpagegroup=1
\lstset{
tabsize = 4, %% set tab space width
showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
numbers = left, %% display line numbers on the left
commentstyle = \color{darkgreen}, %% set comment color
keywordstyle = \color{blue}, %% set keyword color
stringstyle = \color{red}, %% set string color
rulecolor = \color{black}, %% set frame color to avoid being affected by text color
basicstyle = \small \ttfamily , %% set listing font and size
breaklines = true, %% enable line breaking
numberstyle = \tiny,
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  showspaces=false,
  columns=flexible,
  showstringspaces=false,
  morecomment=[l]\%,
}
\begin{document}
	\begin{titlepage}
	\begin{center}
	\large
	University of Warwick \\
	Department of Computer Science \\
	\huge
	\vspace{50mm}
	\rule{\linewidth}{0.5pt} \\
	CS141 \\
	\vspace{5mm}
	\Large
	Functional Programming
	\rule{\linewidth}{0.5pt}
	\vspace{5mm}
	\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{crest_black.eps}
	\end{figure}
	\vspace{37mm}
	Cem Yilmaz \\
	\today
	\end{center}
	\end{titlepage}
	\newpage
	\tableofcontents
	\newpage
	\section{What is Functional Programming}
	\subsection{History}
	
	In 1928, David Hilbert posed the question "Given any true mathematical statement, is there an algorithm for verifying that it is true?". This is now known as the "Entscheidungsproblem", that is, the decision problem. E.g.
	\begin{align*}
		1 = 1 \\
		2 = 2 \\
		2 < 3 \\
		1 < 3
	\end{align*}
In 1931, Kurt Gödel came up with the paradox with the statement "This statement is not provable". If we assume not provable, there is a double negation which implies it is provable. This contradicts the assumption. If we assume true, we have a true statement that is not provable. This is called the incompleteness theorem. This answered the question that mathematics cannot answer every statement.\\
\begin{flushleft}
In 1936, Alonzo Church came up with $\lambda-$calculus as a system for describing algorithms. Kurt Gödel then believed that he can do better. He believed that some algorithms would not be able to be described with $\lambda-$calculus. Kurt then came up with a system of recursive functions. Alonzo Church then claimed that any algorithm that can be described using recursive functions can also be described using $\lambda-$calculus.  \\ 
\end{flushleft}
\begin{flushleft}
Alan Turing then came along and then came up with his own system of describing algorithms utilising Turing machines. However, he also showed that anything described using Turing machine could be described with $\lambda-$calculus. However, notice that despite these being different systems, they were also equivalent in describing algorithms. \\
\subsection{Today}

Today, programming as you know it, for example:
\[
\prod_{i=1}^{4} = 1 \times 2 \times 3 \times 4 
\] 
If we wanted to turn this to the roughly equivalent program in a language such as Java or C
\begin{lstlisting}[language = Java , caption ={Product in Java} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
int x = 1;
for (int = 1; i <= 4; i++) {
	x *= i;
}
\end{lstlisting}
\begin{table}[H]
	\centering
	\caption{Table of results}
	\label{tab:results}
	\begin{tabular}{|c|c|}
		\hline
	Variable & Value \\
	\hline
	$x$ & $1$ \\
	$x$ & $2$ \\
	$x$ & $6$ \\
	$x$ & $24$ \\
	\hline
	\end{tabular}
\end{table}
\end{flushleft}
However, in a function language, we can express it as

\begin{lstlisting}[language = Haskell , caption={Product in Haskell} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
product[1..4]
\end{lstlisting}
That is, product is a function. You can also expand this to be
\begin{lstlisting}[language = Haskell , caption={Expanded Product} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
product[1,2,3,4] 
1 * product[2,3,4]
1 * 2 * product[3,4]
1 * 2 * 3 * product[4]
1 * 2 * 3 * 4
24
\end{lstlisting}
The definition of product function is rather simple:
\begin{lstlisting}[language = Haskell , caption={Product function} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
product [n] = n -- Described in terms of 2 equations. First it checks if there a single item and returns it
product(n:ns) = n * product ns -- Takes the the first item in the list and keeps the rest
\end{lstlisting}
Let us now compare imperative programming with functional \\
\begin{flushleft}
\makebox[\textwidth][c]{
	\centering
	\label{tab:impvsfun}
	\begin{tabular}{|c|c|}
	\hline
	Imperative& Functional \\
	\hline
	Mutation of state & Reduction of expression \\
	Tell the computer how you want to do something & Tell the computer what you want to compute and let it work out how to do it \\
	Statements executed in order specified & Sub-expressions can often be evaluated in an arbitrary order \\
	Loops & Recursion \\
	\hline
	\end{tabular}
}
\end{flushleft}
\subsection{Programming Paradigms}
In history, there used to be a clear distinction between programming paradigms. However, today, this has changed. That is,
\begin{itemize}
	\item Java / C# are now multi-paradigm: They're imperative, object-oriented, functional, etc.
	\item Python, JavaScript, C++ have similarly multi-paradigm.
\end{itemize}
As such, learning functional programming will be useful as paradigms have blended together.
\subsection{What Haskell is good for}
\subsubsection{Web Services}

Furthermore, a particularly nice application to functional programming is that they're good at web services. 
\begin{itemize}
	\item Lots of cool frameworks for developing web applications
	\item Easy to embed domain-specific languages for routing, templates, etc.
	\item Servant: describe web service as a type, automatically generate client programs 
	\item One of the coursework assignments uses a web service written in Haskell to provide a browser-based interface
\end{itemize}
\subsubsection{Domain-specific language}

Domain-specific languages are also a thing. For example, you can write music in a Haskell library to describe music.
\begin{lstlisting}[language = Haskell , caption={Music in Haskell} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
import Mezoo

v1 = d qn :|: g qn :|: fs qn :|:  g en :|: a en :|: bf qn :|: a qn :|: g hn
v2 = d qn :|: ef qn :|: d qn :|: bf_ en :|: a_ en :|: b_ qn :|: a_ qn :|: g_ hn

main = playLive (v1 :-: v2)
\end{lstlisting}
What's cooler is that if we try to compile, we would get an error that the composition is not harmonic, that is, if it does not sound good, it does not compile. In particular,
\begin{itemize}
	\item Major sevenths are not permitted in harmony: Bb and B\_
	\item Direction motion in a perfect octave is forbidden: Bb and B\_, then A and A\_
	\item Parallel octaves are forbidden: A and A\_, then G and G\_
\end{itemize}
\subsubsection{Games}
For example, the game magic cookies utilises functional reactive programming to describe its game logic. It is the same code across different platforms. It is also good for time-travel debugging.
\subsubsection{System Software}
\begin{itemize}
	\item XMonad: Window manager
	\item OS: Mirage (OCaml), House (Haskell) and more
\end{itemize}
\section{Basics of Haskell}
\subsection{Modules}
Haskell code is separated into files called modules. A module file always begin with
\begin{lstlisting}[language = Haskell , caption={Module} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module Whatever where
...
\end{lstlisting}
Note that the filename ends with $.hs$, and is the same as the module name.
\subsection{Imports}
Similarly, you can import nearby modules. For example, for the file $foo.hs$ :
\begin{lstlisting}[language = Haskell , caption={Import} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module foo where
double x = x * 2
\end{lstlisting}
And then in another file,
\begin{lstlisting}[language = Haskell , caption={Import of foo} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module bar where
import Foo
quadruple x = double (double x)
\end{lstlisting}
In the same way, libraries are imported as they are just functions. For example,
\begin{lstlisting}[language = Haskell , caption={Library import} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module Whatever where
import Data.Char
swapCase c =	 if isUpper c
					     then toLower c
				    	 else toUpper c
\end{lstlisting}
\subsection{Definitions}
A Haskell file is a series of definitions. For example, for the code
\begin{lstlisting}[language = Haskell , caption={Defn.hs} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module Defn where
triangle n = sum [1..n]
\end{lstlisting}
On the LHS of $=$ is a name, with zero or more arguments. On the RHS is an expression which utilises the arguments. Note that Haskell does not utilise parentheses. Arguments are separated by whitespace.
\subsection{Lambda Notation and Mapping notations}
Recall that in lambda calculus we denote inputs using lambdas, that is
\begin{align*}
	&\lambda x y . x \times y \\
	=& \lambda x \lambda y . x \times y 
\end{align*}
Similarly, in Haskell, the lambda notation is blended with the mapping arrow. That is, for example, we can define our function $multiply$ in following ways:
\begin{lstlisting}[language = Haskell , caption={Multiply.hs} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
import Multiply where
multiply x y = x * y
multiply = \x y -> x * y
multiply x = \y -> x * y
multiply = \x -> \y -> x * y
\end{lstlisting}
These all are the same thing.
\subsection{Partial Functions}
It is possible to provide a singular argument into a function that takes in multiple arguments. For example, for our code above, if declared $multiply 5$, then we would replace $x$ with $5$. Note that it is $x$ in particular because it is the variable that is declared first. 
\begin{lstlisting}[language = Haskell , caption={Multiply 5} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
multiply = \x y -> y * x
multiply 5 --(\y -> y * 5)
\end{lstlisting}
\subsection{Smooth Operator}

Other than declaring functions, it is also possible to declare operators in a similar fashion. Consider the following code:
\begin{lstlisting}[language = Haskell , caption={Operator} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
x ^^^ y = max x y
\end{lstlisting}
One can spot the similarities. However, note that operator names are made up of symbols rather than letters.
Similarly to partial functions, there are also partially applied operators. For example,
\begin{lstlisting}[language = Haskell , caption={Partially applied operator} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
plusFive = (+ 5)
\end{lstlisting}
This would add a $5$ to any other operator.
\subsection{Difference between a function and an operator}
Functions are a prefix, whilst operators go between arguments (infix). It is possible to treat a function like an operator. Consider the following code:
\begin{lstlisting}[language = Haskell , caption={Function to operator} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
GHCi > 5 `max` 6
6

GHCI> (*) 5 6
30
\end{lstlisting}
For example, the max function is enclosed within $``$ which allows us to use it like an operator.The latter operation is another alternative way of writing it.
\subsection{Pattern Matching}
Consider the following definition of factorial of a variable $x$ :
\begin{lstlisting}[language = Haskell , caption={factorial} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
fac x = if x == 0 
						then 1
						else x * f (x - 1)
\end{lstlisting}
This can be rewritten as
\begin{lstlisting}[language = Haskell , caption={factorial redefined} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
fac x = case x of
		0 -> 1
		n -> n * f (n - 1)
\end{lstlisting}	
You can also express it in top-level patterns. That is, we pattern match our arguments directly
\begin{lstlisting}[language = Haskell , caption={factorial pattern matched} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
fac 0 = 1
fac x = x * f (x - 1)
\end{lstlisting}
Often, Haskell code is written like this
Lastly, you can also introduce "guards" for the code. If we need to check some predicate of the input and not a specific pattern
\begin{lstlisting}[language = Haskell , caption={factorial guard} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
f x
			| x == 0 				= 1
			| otherwise 		= x * f(x-1)
\end{lstlisting}
\section{Data Types}
\subsection{Compiler}
The GHCi is an interpreter and runs a REPL loop, that is
\begin{itemize}
	\item Read
	\item Evaluate
	\item Print
	\item Loop
\end{itemize}
Cabal is a program that manages Haskell packages. The Haskell package repository, Hackage, contains a bunch of packages. It downloads the package and then connects it to GHC. However, instead, we will be using Stack. It is a wrapper around cabal and ghc. It makes them both easier to use and helps with sharing programs across different systems. 
\subsubsection{Compiling}
\begin{tcolorbox}[colback=black!3!white,colframe=black!60!white,title=\begin{defn}Compiling \label{Compiling}\end{defn}]
Compiling is the process of turning raw source code into a format the computer can run.
\end{tcolorbox}
In Haskell, GHC has three main compilation stages:
\[
\text{(Raw source)} \implies \text{Parser} \implies \text{Type Checker} \implies \text{Code Generator} \implies \text{(Binary code)}
\] 
\subsubsection{Types}
In Java, we have types e.g.
\begin{lstlisting}[language = Java , caption={Java data type} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
int x = 5;
\end{lstlisting}
In Haskell, every expression has a type. For example,
\begin{lstlisting}[language = Haskell , caption={Boolean Type} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
someBoolean = True && False || True
\end{lstlisting}
In this case, someBoolean has the type true.
\begin{lstlisting}[language = Haskell , caption={Integer} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
five = min 5 6
\end{lstlisting}
Five has type Integer. Integer does not have an upper bound unlike in other languages.
\begin{lstlisting}[language = Haskell , caption={String} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
string = "Hello, world!"
\end{lstlisting}
In this case, string has the type string.
You can also use GHCi to find the type that a function has. You can
\subsubsection{Type Declarations}
You can declare the type of a function just above it using
\begin{lstlisting}[language = Haskell , caption={Declaration of Data} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
five :: Integer
five = min 5 6
\end{lstlisting}
$::$ is a special piece of notation that declares the data type of a function. However, if every expression has a type, how did we get away without writing them? The answer is, Haskell figures out what types to use. This is called \textit{type inference}. In fact, in Haskell, even if we declare the type, Haskell checks that for us regardless. And if it checks and it does not line up, we get a type error. The benefit of declaring types is to pinpoint any possible errors that occur when compiling. Some errors include but are not limited to:
\begin{itemize}
	\item Giving a function too many arguments
	\item Forgetting arguments
	\item Trying to use a value where it does not make sense
\end{itemize}\\
Types only exist at compile time. The type checker has guaranteed that all types Lin up, so it does not need to keep that information any more, meaning that we cannot check the type of a value at run time. It is also important to note that Haskell is a \textit{strongly typed} language which means that the types are correct before it runs the program. For example, in Python, it is weakly typed and thus it make take you hours to find the error.
\subsubsection{Function types}
In mathematics, the succ function is a function s.t.
\[
succ(n) = n+1
\] 
We might say that $succ$ is a function from integers to integers, otherwise
\[
succ: \mathbb{Z} \to \mathbb{Z}
\] 
In Haskell, it is written the same.
\begin{lstlisting}[language = Haskell , caption={Mapping in Haskell} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
succ :: Integer -> Integer
succ n = n + 1
\end{lstlisting}
\subsubsection{Polymorphism}
In Haskell, we need to find a method to make sure that we can parse a function with a different types. For example, 
\begin{lstlisting}[language = Haskell , caption={Identity Function} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
id x = x
\end{lstlisting}
To give a general type here, we need to use a type variable. We write these with lowercase letters. In particular,
\begin{lstlisting}[language = Haskell , caption={Example} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
id :: a -> a
id x = x
\end{lstlisting}
The compiler will specialise the type for us when we use the function. We can also ignore arguments using
\begin{lstlisting}[language = Haskell , caption={Ignore argument} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
ignoreSecondArgument x y = x
\end{lstlisting}
This function takes two arguments and throws away the second one. Since it doesn't use any specific details about either argument, we can treat both arguments as being polymorphic.
\section{Tuples and Lists}
\subsection{Tuples}
\begin{tcolorbox}[colback=black!3!white,colframe=black!60!white,title=\begin{defn}Tuple \label{Tuple}\end{defn}]
A tuple is a sequence of known, finite length. For example,
\begin{align*}
	(1,3) \in \mathbb{Z}^2
\end{align*}
And in natural language, we know that this equates to "the pair $(1,3)$ is an element of the set of pairs of integers". Indeed, this is not only restricted to pairs, but we could also have
\begin{align*}
	(5,True,0.2) \in \mathbb{Z} \times \mathbb{B} \times \mathbb{Q}
\end{align*}
The number of elements in a tuple is called the dimension.
\end{tcolorbox}
In Haskell, the tuples are represented in a very similar manner. For example,
\begin{lstlisting}[language = Haskell , caption={Tuple} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
(5, "Hello")
\end{lstlisting}
This is the definition of a tuple in Haskell, and this is the only syntax that you require.
\subsection{Types of Tuples}
To declare the types of elements in a tuple, you would similarly declare it in a tuple as well. That is, for example	
\begin{lstlisting}[language = Haskell , caption={Tuple type} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
(False, 5) :: (Bool, Int)
\end{lstlisting}
With this you can also write functions that can take tuples as an argument. For example,
\begin{lstlisting}[language = Haskell , caption={Tuple input} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
combine :: (Int, Int) -> Int
combine (x,y) = x + y
\end{lstlisting}
And indeed functions that also return tuples.
We can similarly also use pattern matching:
\begin{lstlisting}[language = Haskell , caption={Pattern Matching} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
combine p = case p of
	(x,y) -> x + +y
\end{lstlisting}
Pattern matching allows us to inspect the values in a complex type based on its constructors. For tuples, (,) is the constructor. With pattern matching we destructuring, unpacking the pair to get at the values inside of it.
\subsection{Polymorphic Functions}
We can indeed write polymorphic functions over tuples, for example
\begin{lstlisting}[language = Haskell , caption={Polymorphic tuple} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
fst :: (a,b) -> a
fst (x,y) = x
\end{lstlisting}
\subsection{Currying}
We know we can get carry-on functions for things such as
\begin{lstlisting}[language = Haskell , caption={Currying} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
f :: Int -> Int -> Int
f :: Int -> (Int -> Int)
\end{lstlisting}
These two are equivalent. That is, the if we were to put in one argument in a function above, we would get another function that returns int -> int.
The process of taking a function that takes several arguments at once is called currying. However, sometimes we want to write functions over pairs in terms of functions over two arguments. 
\begin{lstlisting}[language = Haskell , caption={Curry and Uncurry} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
curry :: ((a, b) -> c) -> ( a -> b -> c )
uncurry :: (a -> b -> c) -> ((a, b) -> c)
\end{lstlisting}
These functions would allow us to convert how many inputs we take. 
\subsection{Lists}
Lists in Haskell have two constructors
\begin{lstlisting}[language = Haskell , caption={Lists} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
[] :: [a]
\end{lstlisting}
The first constructs an empty list. Notice its type is polymorphic - it could be an empty list of any type. 
Lists in Haskell have two constructors. For literals,
\begin{lstlisting}[language = Haskell , caption={Literals} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
==> [True, False, True]
\end{lstlisting}
Similar with tuples, we use pattern matching to restructure a list.
\begin{lstlisting}[language = Haskell , caption={Destructure} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
startsWithFive :: [int] -> Bool
startsWithFive [] = False
startsWithFive (x:xs) = x == 5
\end{lstlisting}
We can also syntactic sugar this by
\begin{lstlisting}[language = Haskell , caption={Nest Patterning} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
startsWithFive :: [Int] -> Bool
startsWithFive (5:xs) = True
startsWithFive _ = False
\end{lstlisting}
\subsection{Head and Tail}
We can get the head and tail of a list by using functions which are defined as
\begin{lstlisting}[language = Haskell , caption={Heads and Tail} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
head :: [a] -> a
tail :: [a] -> [a]
\end{lstlisting}
However, we cannot get the first the head for an empty list. Furthermore, lists are NOT arrays. Operations on a list are too complex and require too many steps. 
\subsection{List Comprehensions}
Haskell borrows comprehension syntax for its list. That is,
\begin{lstlisting}[language = Haskell , caption={List Comprehension} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
a = [ x^2 | x <- [1,2,3] ]
\end{lstlisting}
We call $x <- [1,2,3]$ a generator. It binds each of the values in turn so they can be used. $x^2$ is an expression. In other words, the code expresses
\begin{align*}
	a = \{ x^2 | x \in \{ 1,2,3 \} \}
\end{align*}
In particular, for a list such as 
\begin{lstlisting}[language = Haskell , caption={Multiple Generators} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
[ (x,y) | x <- [0..3], y <- [0..x] ]
// The output is
[ (0,0)
, (1,0), (1,1)
, (2,0), (2,1), (2,2)
, (3,0), (3,1), (3,2), (3,3)
]
\end{lstlisting}
We can also set up rules for our generators. For example, for the equations
\begin{align*}
	Evens = \{ x | x \in \mathbb{N}, \text{$x$ is even} \}
\end{align*}
In Haskell,
\begin{lstlisting}[language = Haskell , caption={Even} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
evens = [ x | x <- [0..], even x]
\end{lstlisting}
We call this boolean predicate a guard.
\section{Map and Filter}
\subsection{Filtering}
Suppose our previous definition for square numbers. However, how can we get even square numbers?
Our first option is to wrap it with another list comprehension:
\begin{lstlisting}[language = Haskell , caption={filtering} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
squares = [ x^2 | x <- [1..] ]
evenSquares = [ s | s <- squares, even s]
\end{lstlisting}
However, we can use a filter function as well
\begin{lstlisting}[language = Haskell , caption={filter} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
filter :: (a -> Bool) -> [a] -> [a]
evenSquares = filter (\s -> even s) squares --which is the same as
evenSquares = filter even squares
\end{lstlisting}
This is called $\eta$ reduction. 
\subsection{Mapping}
Filter works well until we require to apply a function to a whole list. The map function is defined with the following arguments:
\begin{lstlisting}[language = Haskell , caption={Mapping} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
map :: (a -> b) -> [a] -> [b]
\end{lstlisting}
For example,
\begin{lstlisting}[language = Haskell , caption={Mapping succ} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
GHCi> map succ [1,2,3]
[2,3,4]
\end{lstlisting}
\subsection{Ranges}
Lists can be used to write a range of values without having to explicitly type them. The syntax for this is as follows:
\begin{lstlisting}[language = Haskell , caption={Range} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
[x .. z]
\end{lstlisting}
where $x$ is the start of the range and $z$ is the end of the range. It is also possible to have second element and this can set the step amount. For example
\begin{lstlisting}[language = Haskell , caption={Step Range} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
[2,4 .. 16]
\end{lstlisting}
This would include all even numbers from and including $2$ to $16$. However note that ranges must always proceed in an arithmetic progression. However, note that the range syntax is a little broken for floating point values.
\section{Type Classes}
Type classes allow us to define specific rules for functions whose we don't know the type.
\subsection{Eq class}
\begin{lstlisting}[language = Haskell , caption={Eq Class} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
(==) Eq a where
	(==) :: a -> a -> Bool
\end{lstlisting}
The first line defines the name of the type of class (Eq) and a type variable (a) to use in the definitions. After that comes a series of function type definitions, without implementations. The type class declaration is a specification that must be implemented for each type that wants to be part of the Eq type class. This is why if you type
\begin{lstlisting}[language = Haskell , caption={Class} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
:t 5
-- The output is --
5 :: Num p => p 
\end{lstlisting}
And at that point, the program itself still has not specified whether its a float, int, etc. but has defined it as a num type class. Num type class defines things such as multiplication, division, addition, subtraction etc.
\subsection{Instances}
After defining the type Eq, we can put an instance for it. We can declare that a type is a member of a type class by writing an instance declaration. For example,
\begin{lstlisting}[language = Haskell , caption={Instance} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
class Eq a where
(==) :: a -> a -> Bool

instance Eq Bool where
True == True = True
False == False = True
_ == _ = False
\end{lstlisting}
Note that the underscore denotes anything else.
\subsection{Using Type Classes}
Consider the code
\begin{lstlisting}[language = Haskell , caption={Plus} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
double :: n -> n
double \x -> x + x
\end{lstlisting}
This would create problems as $n$ is not specified for number functions, when we mean numbers. As such,
\begin{lstlisting}[language = Haskell , caption={PlusFixed} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
double :: (Num n) => n -> n
double x = x + x
\end{lstlisting}
And now plus is defined as well as we know its a num.
\subsection{Important Type Classes}
\subsubsection{Eq}
The eq type class lets us test two values for equality of they are of the same type.
\subsubsection{Num}
Num gives us access to standard mathematical operations.
\subsubsection{Ord}
The ord type classes imposes a total ordering on elements of the type.
\subsubsection{Read and Show}
Read and Show lets us convert values to and from strings. Read converts from string and show converts to string.
\subsubsection{Integral}
This type of class is used for division where it is rounded. It is rounded division.
\subsubsection{Fractional}
Fractional implements division without rounding.
\end{document}
