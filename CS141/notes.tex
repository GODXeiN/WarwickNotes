\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{amsfonts}
\usepackage{titling}
\usepackage{lipsum}
\usepackage[left=1in, right=1in, bottom=1in, top=1in]{geometry}
\usepackage{amsthm}
\usepackage{tcolorbox}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{tikz}
\usepackage{cases}
\usepackage{apacite}
\usepackage{tkz-berge}
\usepackage{url}
\usepackage{tgtermes}
\usepackage{sectsty}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{float}
\usepackage{amsmath, amssymb}


% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{color}
\newcommand{\incfig}[2][1]{%
    \def\svgwidth{#1\columnwidth}
    \import{./figures/}{#2.pdf_tex}
}

%mathstyling
\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]
\newtheorem{axiom}{Axiom}
\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}

\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}

\pdfsuppresswarningpagegroup=1
\lstset{
tabsize = 4, %% set tab space width
showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
numbers = left, %% display line numbers on the left
commentstyle = \color{darkgreen}, %% set comment color
keywordstyle = \color{blue}, %% set keyword color
stringstyle = \color{red}, %% set string color
rulecolor = \color{black}, %% set frame color to avoid being affected by text color
basicstyle = \small \ttfamily , %% set listing font and size
breaklines = true, %% enable line breaking
numberstyle = \tiny,
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  showspaces=false,
  columns=flexible,
  showstringspaces=false,
  morecomment=[l]\%,
}
\begin{document}
	\begin{titlepage}
	\begin{center}
	\large
	University of Warwick \\
	Department of Computer Science \\
	\huge
	\vspace{50mm}
	\rule{\linewidth}{0.5pt} \\
	CS141 \\
	\vspace{5mm}
	\Large
	Functional Programming
	\rule{\linewidth}{0.5pt}
	\vspace{5mm}
	\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{crest_black.eps}
	\end{figure}
	\vspace{37mm}
	Cem Yilmaz \\
	\today
	\end{center}
	\end{titlepage}
	\newpage
	\tableofcontents
	\newpage
	\section{What is Functional Programming}
	\subsection{History}
	
	In 1928, David Hilbert posed the question "Given any true mathematical statement, is there an algorithm for verifying that it is true?". This is now known as the "Entscheidungsproblem", that is, the decision problem. E.g.
	\begin{align*}
		1 = 1 \\
		2 = 2 \\
		2 < 3 \\
		1 < 3
	\end{align*}
In 1931, Kurt Gödel came up with the paradox with the statement "This statement is not provable". If we assume not provable, there is a double negation which implies it is provable. This contradicts the assumption. If we assume true, we have a true statement that is not provable. This is called the incompleteness theorem. This answered the question that mathematics cannot answer every statement.\\
\begin{flushleft}
In 1936, Alonzo Church came up with $\lambda-$calculus as a system for describing algorithms. Kurt Gödel then believed that he can do better. He believed that some algorithms would not be able to be described with $\lambda-$calculus. Kurt then came up with a system of recursive functions. Alonzo Church then claimed that any algorithm that can be described using recursive functions can also be described using $\lambda-$calculus.  \\ 
\end{flushleft}
\begin{flushleft}
Alan Turing then came along and then came up with his own system of describing algorithms utilising Turing machines. However, he also showed that anything described using Turing machine could be described with $\lambda-$calculus. However, notice that despite these being different systems, they were also equivalent in describing algorithms. \\
\subsection{Today}

Today, programming as you know it, for example:
\[
\prod_{i=1}^{4} = 1 \times 2 \times 3 \times 4 
\] 
If we wanted to turn this to the roughly equivalent program in a language such as Java or C
\begin{lstlisting}[language = Java , caption ={Product in Java} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
int x = 1;
for (int = 1; i <= 4; i++) {
	x *= i;
}
\end{lstlisting}
\begin{table}[H]
	\centering
	\caption{Table of results}
	\label{tab:results}
	\begin{tabular}{|c|c|}
		\hline
	Variable & Value \\
	\hline
	$x$ & $1$ \\
	$x$ & $2$ \\
	$x$ & $6$ \\
	$x$ & $24$ \\
	\hline
	\end{tabular}
\end{table}
\end{flushleft}
However, in a function language, we can express it as

\begin{lstlisting}[language = Haskell , caption={Product in Haskell} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
product[1..4]
\end{lstlisting}
That is, product is a function. You can also expand this to be
\begin{lstlisting}[language = Haskell , caption={Expanded Product} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
product[1,2,3,4] 
1 * product[2,3,4]
1 * 2 * product[3,4]
1 * 2 * 3 * product[4]
1 * 2 * 3 * 4
24
\end{lstlisting}
The definition of product function is rather simple:
\begin{lstlisting}[language = Haskell , caption={Product function} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
product [n] = n -- Described in terms of 2 equations. First it checks if there a single item and returns it
product(n:ns) = n * product ns -- Takes the the first item in the list and keeps the rest
\end{lstlisting}
Let us now compare imperative programming with functional \\
\begin{flushleft}
\makebox[\textwidth][c]{
	\centering
	\label{tab:impvsfun}
	\begin{tabular}{|c|c|}
	\hline
	Imperative& Functional \\
	\hline
	Mutation of state & Reduction of expression \\
	Tell the computer how you want to do something & Tell the computer what you want to compute and let it work out how to do it \\
	Statements executed in order specified & Sub-expressions can often be evaluated in an arbitrary order \\
	Loops & Recursion \\
	\hline
	\end{tabular}
}
\end{flushleft}
\subsection{Programming Paradigms}
In history, there used to be a clear distinction between programming paradigms. However, today, this has changed. That is,
\begin{itemize}
	\item Java / C# are now multi-paradigm: They're imperative, object-oriented, functional, etc.
	\item Python, JavaScript, C++ have similarly multi-paradigm.
\end{itemize}
As such, learning functional programming will be useful as paradigms have blended together.
\subsection{What Haskell is good for}
\subsubsection{Web Services}

Furthermore, a particularly nice application to functional programming is that they're good at web services. 
\begin{itemize}
	\item Lots of cool frameworks for developing web applications
	\item Easy to embed domain-specific languages for routing, templates, etc.
	\item Servant: describe web service as a type, automatically generate client programs 
	\item One of the coursework assignments uses a web service written in Haskell to provide a browser-based interface
\end{itemize}
\subsubsection{Domain-specific language}

Domain-specific languages are also a thing. For example, you can write music in a Haskell library to describe music.
\begin{lstlisting}[language = Haskell , caption={Music in Haskell} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
import Mezoo

v1 = d qn :|: g qn :|: fs qn :|:  g en :|: a en :|: bf qn :|: a qn :|: g hn
v2 = d qn :|: ef qn :|: d qn :|: bf_ en :|: a_ en :|: b_ qn :|: a_ qn :|: g_ hn

main = playLive (v1 :-: v2)
\end{lstlisting}
What's cooler is that if we try to compile, we would get an error that the composition is not harmonic, that is, if it does not sound good, it does not compile. In particular,
\begin{itemize}
	\item Major sevenths are not permitted in harmony: Bb and B\_
	\item Direction motion in a perfect octave is forbidden: Bb and B\_, then A and A\_
	\item Parallel octaves are forbidden: A and A\_, then G and G\_
\end{itemize}
\subsubsection{Games}
For example, the game magic cookies utilises functional reactive programming to describe its game logic. It is the same code across different platforms. It is also good for time-travel debugging.
\subsubsection{System Software}
\begin{itemize}
	\item XMonad: Window manager
	\item OS: Mirage (OCaml), House (Haskell) and more
\end{itemize}
\section{Basics of Haskell}
\subsection{Modules}
Haskell code is separated into files called modules. A module file always begin with
\begin{lstlisting}[language = Haskell , caption={Module} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module Whatever where
...
\end{lstlisting}
Note that the filename ends with $.hs$, and is the same as the module name.
\subsection{Imports}
Similarly, you can import nearby modules. For example, for the file $foo.hs$ :
\begin{lstlisting}[language = Haskell , caption={Import} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module foo where
double x = x * 2
\end{lstlisting}
And then in another file,
\begin{lstlisting}[language = Haskell , caption={Import of foo} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module bar where
import Foo
quadruple x = double (double x)
\end{lstlisting}
In the same way, libraries are imported as they are just functions. For example,
\begin{lstlisting}[language = Haskell , caption={Library import} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module Whatever where
import Data.Char
swapCase c =	 if isUpper c
					     then toLower c
				    	 else toUpper c
\end{lstlisting}
\subsection{Definitions}
A Haskell file is a series of definitions. For example, for the code
\begin{lstlisting}[language = Haskell , caption={Defn.hs} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
module Defn where
triangle n = sum [1..n]
\end{lstlisting}
On the LHS of $=$ is a name, with zero or more arguments. On the RHS is an expression which utilises the arguments. Note that Haskell does not utilise parentheses. Arguments are separated by whitespace.
\subsection{Lambda Notation and Mapping notations}
Recall that in lambda calculus we denote inputs using lambdas, that is
\begin{align*}
	&\lambda x y . x \times y \\
	=& \lambda x \lambda y . x \times y 
\end{align*}
Similarly, in Haskell, the lambda notation is blended with the mapping arrow. That is, for example, we can define our function $multiply$ in following ways:
\begin{lstlisting}[language = Haskell , caption={Multiply.hs} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
import Multiply where
multiply x y = x * y
multiply = \x y -> x * y
multiply x = \y -> x * y
multiply = \x -> \y -> x * y
\end{lstlisting}
These all are the same thing.
\subsection{Partial Functions}
It is possible to provide a singular argument into a function that takes in multiple arguments. For example, for our code above, if declared $multiply 5$, then we would replace $x$ with $5$. Note that it is $x$ in particular because it is the variable that is declared first. 
\begin{lstlisting}[language = Haskell , caption={Multiply 5} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
multiply = \x y -> y * x
multiply 5 --(\y -> y * 5)
\end{lstlisting}
\subsection{Smooth Operator}

Other than declaring functions, it is also possible to declare operators in a similar fashion. Consider the following code:
\begin{lstlisting}[language = Haskell , caption={Operator} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
x ^^^ y = max x y
\end{lstlisting}
One can spot the similarities. However, note that operator names are made up of symbols rather than letters.
Similarly to partial functions, there are also partially applied operators. For example,
\begin{lstlisting}[language = Haskell , caption={Partially applied operator} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
plusFive = (+ 5)
\end{lstlisting}
This would add a $5$ to any other operator.
\subsection{Difference between a function and an operator}
Functions are a prefix, whilst operators go between arguments (infix). It is possible to treat a function like an operator. Consider the following code:
\begin{lstlisting}[language = Haskell , caption={Function to operator} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
GHCi > 5 `max` 6
6

GHCI> (*) 5 6
30
\end{lstlisting}
For example, the max function is enclosed within $``$ which allows us to use it like an operator.The latter operation is another alternative way of writing it.
\subsection{Pattern Matching}
Consider the following definition of factorial of a variable $x$ :
\begin{lstlisting}[language = Haskell , caption={factorial} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
fac x = if x == 0 
						then 1
						else x * f (x - 1)
\end{lstlisting}
This can be rewritten as
\begin{lstlisting}[language = Haskell , caption={factorial redefined} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
fac x = case x of
		0 -> 1
		n -> n * f (n - 1)
\end{lstlisting}	
You can also express it in top-level patterns. That is, we pattern match our arguments directly
\begin{lstlisting}[language = Haskell , caption={factorial pattern matched} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
fac 0 = 1
fac x = x * f (x - 1)
\end{lstlisting}
Often, Haskell code is written like this
Lastly, you can also introduce "guards" for the code. If we need to check some predicate of the input and not a specific pattern
\begin{lstlisting}[language = Haskell , caption={factorial guard} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
f x
			| x == 0 				= 1
			| otherwise 		= x * f(x-1)
\end{lstlisting}
\section{Data Types}
\subsection{Compiler}
The GHCi is an interpreter and runs a REPL loop, that is
\begin{itemize}
	\item Read
	\item Evaluate
	\item Print
	\item Loop
\end{itemize}
Cabal is a program that manages Haskell packages. The Haskell package repository, Hackage, contains a bunch of packages. It downloads the package and then connects it to GHC. However, instead, we will be using Stack. It is a wrapper around cabal and ghc. It makes them both easier to use and helps with sharing programs across different systems. 
\subsubsection{Compiling}
\begin{tcolorbox}[colback=black!3!white,colframe=black!60!white,title=\begin{defn}Compiling \label{Compiling}\end{defn}]
Compiling is the process of turning raw source code into a format the computer can run.
\end{tcolorbox}
In Haskell, GHC has three main compilation stages:
\[
\text{(Raw source)} \implies \text{Parser} \implies \text{Type Checker} \implies \text{Code Generator} \implies \text{(Binary code)}
\] 
\subsubsection{Types}
In Java, we have types e.g.
\begin{lstlisting}[language = Java , caption={Java data type} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
int x = 5;
\end{lstlisting}
In Haskell, every expression has a type. For example,
\begin{lstlisting}[language = Haskell , caption={Boolean Type} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
someBoolean = True && False || True
\end{lstlisting}
In this case, someBoolean has the type true.
\begin{lstlisting}[language = Haskell , caption={Integer} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
five = min 5 6
\end{lstlisting}
Five has type Integer. Integer does not have an upper bound unlike in other languages.
\begin{lstlisting}[language = Haskell , caption={String} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
string = "Hello, world!"
\end{lstlisting}
In this case, string has the type string.
You can also use GHCi to find the type that a function has. You can
\subsubsection{Type Declarations}
You can declare the type of a function just above it using
\begin{lstlisting}[language = Haskell , caption={Declaration of Data} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
five :: Integer
five = min 5 6
\end{lstlisting}
$::$ is a special piece of notation that declares the data type of a function. However, if every expression has a type, how did we get away without writing them? The answer is, Haskell figures out what types to use. This is called \textit{type inference}. In fact, in Haskell, even if we declare the type, Haskell checks that for us regardless. And if it checks and it does not line up, we get a type error. The benefit of declaring types is to pinpoint any possible errors that occur when compiling. Some errors include but are not limited to:
\begin{itemize}
	\item Giving a function too many arguments
	\item Forgetting arguments
	\item Trying to use a value where it does not make sense
\end{itemize}\\
Types only exist at compile time. The type checker has guaranteed that all types Lin up, so it does not need to keep that information any more, meaning that we cannot check the type of a value at run time. It is also important to note that Haskell is a \textit{strongly typed} language which means that the types are correct before it runs the program. For example, in Python, it is weakly typed and thus it make take you hours to find the error.
\subsubsection{Function types}
In mathematics, the succ function is a function s.t.
\[
succ(n) = n+1
\] 
We might say that $succ$ is a function from integers to integers, otherwise
\[
succ: \mathbb{Z} \to \mathbb{Z}
\] 
In Haskell, it is written the same.
\begin{lstlisting}[language = Haskell , caption={Mapping in Haskell} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
succ :: Integer -> Integer
succ n = n + 1
\end{lstlisting}
\subsubsection{Polymorphism}
In Haskell, we need to find a method to make sure that we can parse a function with a different types. For example, 
\begin{lstlisting}[language = Haskell , caption={Identity Function} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
id x = x
\end{lstlisting}
To give a general type here, we need to use a type variable. We write these with lowercase letters. In particular,
\begin{lstlisting}[language = Haskell , caption={Example} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
id :: a -> a
id x = x
\end{lstlisting}
The compiler will specialise the type for us when we use the function. We can also ignore arguments using
\begin{lstlisting}[language = Haskell , caption={Ignore argument} , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
ignoreSecondArgument x y = x
\end{lstlisting}
This function takes two arguments and throws away the second one. Since it doesn't use any specific details about either argument, we can treat both arguments as being polymorphic.
\end{document}
